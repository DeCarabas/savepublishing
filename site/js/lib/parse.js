// Generated by CoffeeScript 1.3.3
(function() {
  var ELEMENT_NODE, TEXT_NODE, blockEls, blocks, entities, textuals, walk, wrap,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  TEXT_NODE = 3;

  ELEMENT_NODE = 1;

  console.log('called parse.js');

  String.prototype.shrink = function() {
    return this;
  };

  entities = /[&\"><]/g;

  String.prototype.entities = function() {
    var replace;
    replace = function(char) {
      switch (char) {
        case '&':
          return '&amp;';
        case '"':
          return '&quot;';
        case '>':
          return '&gt;';
        case '<':
          return '&lt;';
      }
    };
    return this.replace(entities, function(a) {
      return replace(a);
    });
  };

  String.prototype.clean = function() {
    var str;
    str = this.replace(/\s+/g, ' ').replace(/\n+/g, ' ');
    str = str.replace(/^\s*$/, '');
    str = str.entities();
    return str;
  };

  Element.prototype.display = function() {
    return $(this).css('display');
  };

  blocks = ['block', 'inline-block', 'table-cell', 'table-caption', 'list-item', 'none'];

  blockEls = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'BODY', 'BR'];

  textuals = ['SPAN', 'A', 'EM', 'B', 'STRONG', 'I'];

  Element.prototype.isBlockLike = function() {
    var _ref, _ref1;
    return (_ref = this.display(), __indexOf.call(blocks, _ref) >= 0) || (_ref1 = this.nodeName, __indexOf.call(blockEls, _ref1) >= 0);
  };

  Element.prototype.getWrapped = function() {
    var n, text;
    text = $(this).text();
    n = this.nodeName;
    console.log(n);
    if (n === 'B' || n === 'STRONG') {
      "*" + text + "*";
    } else if (n === 'EM' || n === 'I') {
      "_" + text + "_";
    }
    return text;
  };

  Text.prototype.append = function(str) {
    return this.nodeValue = this.nodeValue + str;
  };

  Text.prototype.isBlockLike = function() {
    return false;
  };

  Object.prototype.isBlockLike = function() {
    return false;
  };

  Array.prototype.concatenate = function() {
    if (this.length > 0) {
      return "<span class=\"socialtext\">[" + (this.join(" ")) + "]</span>";
    }
  };

  Node.prototype.isTextual = function() {
    var _ref;
    return (this.nodeType === ELEMENT_NODE && (_ref = this.nodeName, __indexOf.call(textuals, _ref) >= 0)) || this.nodeType === TEXT_NODE;
  };

  Node.prototype.isIgnorable = function() {
    return this.nodeType === 8 || this === void 0 || /^[\t\n\r ]+$/.test(this.data);
  };

  wrap = function(text) {
    return "<span class=\"socialtext-text\">" + text + "</span>";
  };

  $.fn.dress = function() {
    return this.addClass("sociatext-text");
  };

  walk = function(el) {
    var eltype, node, txt, _i, _len, _ref, _results;
    eltype = el != null ? el.nodeType : void 0;
    if (el.isIgnorable()) {

    } else if (eltype === TEXT_NODE) {
      console.log(el);
      el.nodeValue = "TEXT NODE: [[[" + el.nodeValue + "]]]";
      return console.log(el);
    } else if (eltype === ELEMENT_NODE && el.isTextual()) {
      txt = $(el).text();
      return el.nodeValue = "TEXTUAL NODE: [[[" + txt + "]]]";
    } else if (eltype === ELEMENT_NODE) {
      $(el).dress();
      _ref = el.childNodes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        _results.push(walk(node));
      }
      return _results;
    }
  };

  $(function() {
    walk(document.body);
    return $('.socialtext-text').css({
      display: 'block',
      border: '1 px dotted red'
    });
  });

}).call(this);
